import{_ as e,o as c,c as o,e as d}from"./app.bb88cfe0.js";const a={},n=d('<h1 id="基础问答" tabindex="-1"><a class="header-anchor" href="#基础问答" aria-hidden="true">#</a> 基础问答</h1><h2 id="为什么-mc-的优化如此糟糕" tabindex="-1"><a class="header-anchor" href="#为什么-mc-的优化如此糟糕" aria-hidden="true">#</a> 为什么 MC 的优化如此糟糕？</h2><p>答：有以下几个原因： （1） <code>OpenGL</code> 本身性能不差，但是选用的版本实在是太老旧了，而且着色器代码有具有极大的优化空间； （2） <code>lwjgl</code> 封装加上 <code>Blaze3d</code> 封装让代码效率打了折扣； （3） 游戏渲染和主进程绑定在一起，也就意味着虽然 <code>GPU</code> 可能有空闲，但是由于主进程运算阻塞，导致 <code>FPS</code> 降低； （4） 部分优化完全可以达到很好的效果，但是 Mojang 没能力做（例如 <code>Sodium</code> 或者 <code>OptiFine</code> 的优化）。 换言之： 从最底层看，御三家的 <code>OpenGL</code> 实现做的参差不齐； 往上看 <code>OpenGL</code> 本身，历史包袱重，而且 <code>Mojang</code> 用的是旧的方法，新的用了也不会； 看引擎： <code>lwjgl</code> 也就 <code>MC</code> 在用了，小厂自研，优化一般，再加上 <code>Java</code> 拖累； 看游戏架构：渲染与其他操作绑定同步，只要别的地方出岔子，渲染就卡； 再看看渲染代码：优化二字完全没体现，能用就行； 最后看总体：一代不如一代。</p>',3),t=[n];function r(i,s){return c(),o("div",null,t)}const l=e(a,[["render",r],["__file","science.html.vue"]]);export{l as default};
