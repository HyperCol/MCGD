import{_ as o,o as e,c as d,e as c}from"./app-QibtgeR8.js";const r={},t=c('<h2 id="延迟渲染光影用了光线追踪技术吗" tabindex="-1"><a class="header-anchor" href="#延迟渲染光影用了光线追踪技术吗" aria-hidden="true">#</a> 延迟渲染光影用了光线追踪技术吗？</h2><p>延迟渲染的版本并未引入任何光线追踪技术，两者没有关联性。</p><ul><li><p>为保证大多数设备可用性，延迟渲染版本使用了传统光栅化渲染。</p></li><li><p>在 Java 版中，延迟渲染覆盖了九成以上的常见光影，包括一些 <em>引入了光线追踪技术</em> 的光影如 <code>SEUS PTGI</code> 。这意味着两者其实可以叠加使用。</p></li></ul><h2 id="java-版的着色器叫-光影-基岩版的着色器就只能叫-着色器-或-伪光影" tabindex="-1"><a class="header-anchor" href="#java-版的着色器叫-光影-基岩版的着色器就只能叫-着色器-或-伪光影" aria-hidden="true">#</a> Java 版的着色器叫 <code>光影</code>，基岩版的着色器就只能叫 <code>着色器</code> 或 <code>伪光影</code>？</h2><ul><li><p>从图形学上讲， <code>光影</code> 的<strong>专业名称</strong>就是 <code>着色器</code> ：</p></li><li><p>光影只是 <strong>国内的另一种好听的说法</strong> ，就像你可以把 <code>引力波</code> 称作 <code>时空涟漪</code>。</p></li><li><p>基岩版由于 <code>接口</code> <strong>先天的缺乏</strong> 以及 <strong>移动设备性能不足</strong>，无法像 Java 版一样做出 <code>效果相对完整</code> 的着色器，但它仍然叫做光影。</p></li><li><p>有一种说法是，<code>基岩版 PE 端</code> 光影没有实时阴影，不配叫光影。</p></li><li><p>然而 <code>光影</code> 二字，<strong>从来都不是</strong> 指代实时阴影，也 <strong>不会有任何</strong> 一位光影作者会提出 <code>没有实时阴影就不是光影</code> 这种观点！</p></li></ul><h2 id="基岩版的光影是贴图直接-糊-上去的" tabindex="-1"><a class="header-anchor" href="#基岩版的光影是贴图直接-糊-上去的" aria-hidden="true">#</a> 基岩版的光影是贴图直接“糊”上去的？</h2><ul><li><p>上文提到基岩版无法做出与 <code>Java 版</code> 一样的光影，缺陷相对多很多，但也并 <strong>没有简单到使用</strong> <code>图片粘贴</code> 等技术的地步。</p></li><li><p>着色器的 <strong>渲染</strong> 由 <strong>算法</strong> 完成，可以是 <strong>简单粗暴</strong> 的 <code>镜面反射场景</code>，但 <strong>不可能用贴图做到</strong>。</p></li><li><p>提出该观点的人大可拆开他们所谓的 <code>贴图光影 文件</code>，通过找到所有 <strong>疑似使用</strong> 该技术的图片来 <strong>佐证</strong> 他们的观点，否则只能是以下两种情况：</p><ul><li><p><strong>道听途说的错误说法；</strong></p></li><li><p><strong>将同样加载形式的 <code>纹理包</code> 与 <code>光影包</code> 混淆了。</strong></p></li></ul></li></ul><h2 id="基岩版-的一些有特殊效果的纹理包叫做-伪光影" tabindex="-1"><a class="header-anchor" href="#基岩版-的一些有特殊效果的纹理包叫做-伪光影" aria-hidden="true">#</a> <code>基岩版</code> 的一些有特殊效果的纹理包叫做 <code>伪光影</code> ？</h2><ul><li><p><code>着色器</code> 与 <code>纹理包</code> 是不同的概念。</p></li><li><p>作为纹理包，其能实现的主要功能即<strong>纹理的替换</strong>。</p></li><li><p>假若通过一些 <code>特殊手段</code>（如修改雾气）使其表现出<strong>如同被着色器渲染出的效果</strong>，最终结果也是极其的勉强。</p></li><li><p>而实际上，<code>着色器</code> 支持的功能远不止这些。要达到 <code>伪</code> 的级别，也应当将一个着色器能实现的<strong>大部分效果</strong>复现出来，包括<code>光照</code>、<code>阴影</code>、<code>大气</code>、<code>水波</code>等<strong>主要场景因素</strong>。</p></li><li><p>显然，想要在一个主要功能为 <code>替换贴图</code> 的纹理包去实现这些效果<strong>并不现实</strong>。</p></li></ul>',9),n=[t];function s(i,a){return e(),d("div",null,n)}const g=o(r,[["render",s],["__file","qas.html.vue"]]);export{g as default};
