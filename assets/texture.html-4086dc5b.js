import{_ as e,o,c as d,e as c}from"./app-780891ab.js";const i={},r=c('<h1 id="资源包-纹理包-问答" tabindex="-1"><a class="header-anchor" href="#资源包-纹理包-问答" aria-hidden="true">#</a> 资源包（纹理包）问答</h1><h2 id="资源包-纹理包是否有优化空间" tabindex="-1"><a class="header-anchor" href="#资源包-纹理包是否有优化空间" aria-hidden="true">#</a> 资源包 / 纹理包是否有优化空间？</h2><p>可能有。</p><ul><li>纹理包由 Mojang 与 OptiFine / Iris 提供支持。在纹理加载的层面可以继续优化，但显然这不是纹理包开发者能做的事情；</li><li>从纹理包开发角度讲，每多一张贴图，运行时就会多一份对硬件的压力。当然，他们可以做一些“优化”——不去做不常见的方块与物品贴图，如果你认为这也算优化。</li></ul><h2 id="加载资源包-纹理包后-还有原版的方块物品" tabindex="-1"><a class="header-anchor" href="#加载资源包-纹理包后-还有原版的方块物品" aria-hidden="true">#</a> 加载资源包 / 纹理包后，还有原版的方块物品？</h2><p><strong>很多资源包都属于个人作品，制作速度很慢，而 Minecraft 的纹理包贴图可以达到上万张。</strong></p><ul><li>如果你发现资源包有此类问题，需要自行检查作者发布的资源包是 <code>多个版本叠加使用</code> ，还是 <code>最新版本包括所有贴图</code> 的形式。</li><li>如果是 <code>叠加包</code>，开发者一定会在 <strong>公告</strong> 等地方标明；</li><li>如果没有，那只是 <strong>资源包未完善</strong> ，上文也说到这也许是开发者“优化”资源包的方式。</li><li>请勿拿这个问题 <strong>困扰</strong> 纹理包作者，更不要 <strong>盲目反复催促</strong> 作者制作你想要的贴图！</li></ul><h2 id="加载资源包-纹理包后帧数远低于预期" tabindex="-1"><a class="header-anchor" href="#加载资源包-纹理包后帧数远低于预期" aria-hidden="true">#</a> 加载资源包 / 纹理包后帧数远低于预期？</h2><p><strong>可能是内存或显存溢出</strong>。加载资源包时占用达到瓶颈后寻求替补的顺序是：<code>运行内存（RAM）&gt; 显存（VRAM）&gt; 虚拟内存（CPU）</code>。三者分别对应内存条、显卡、磁盘；</p><p>当游戏帧数明显低于你的预期时，可搭配任务管理器分两步检查。</p><ul><li>检查 <strong>运行内存（RAM）使用量</strong> ：<code>已提交</code> 的 <strong>现有内存</strong> 是否已经超过了你的 <code>内存条容量</code> 。若超过，请更换低分辨率资源包，升级内存条容量；</li><li>检查 <strong>GPU-内存利用率</strong> ：若 <code>专用GPU</code> 的内存使用率满载，并已溢出一部分至 <code>共享GPU</code> 内存，即显存溢出。此时需更换低分辨率资源包，或升级显卡。</li></ul><h2 id="加载资源包-纹理包需要多少内存" tabindex="-1"><a class="header-anchor" href="#加载资源包-纹理包需要多少内存" aria-hidden="true">#</a> 加载资源包 / 纹理包需要多少内存？</h2><p>最清楚这个答案的应该是你自己的设备，而不是开发者或任何别的玩家！</p><ul><li>在纹理包之外，游戏版本、Java版本、使用的光影、玩家视距、使用的模组、数据包、地图等都可能导致内存与其他人不同；</li><li>在纹理包之内，不同作者的进度不同，贴图数量、分辨率不同，对配置的要求同样无法通用；</li><li>最快获取答案的方式是你自己逐个测试，而不是问其他人！</li></ul><h2 id="资源包-纹理包是否需要解压使用" tabindex="-1"><a class="header-anchor" href="#资源包-纹理包是否需要解压使用" aria-hidden="true">#</a> 资源包 / 纹理包是否需要解压使用？</h2><p>看 <code>使用说明</code> ，一般可在下载资源包的群/频道的群公告、精华消息、群文件，或私信的网盘链接等处寻得。</p><ul><li>不同作者有不同习惯，有些习惯将多个资源包合并成一个压缩包，有些则是直接使用，还有些因为用中文命名贴图，导致未解压时资源包重载失败。</li><li>鉴于资源包原本即可解压使用，最稳妥的方式是将所有拿到手的资源包解压后检查文件结构，再使用。</li></ul><h2 id="资源包-纹理包加载是否有优先级" tabindex="-1"><a class="header-anchor" href="#资源包-纹理包加载是否有优先级" aria-hidden="true">#</a> 资源包 / 纹理包加载是否有优先级？</h2><p>有。</p><ul><li>在 <code>设置-&gt;资源包</code> 中，加载顺序由下往上，新加载的资源包会覆盖旧的同名贴图；</li><li>排在底部的资源包会补足上方资源包缺失的贴图。</li></ul><h2 id="光追资源包-纹理包是什么" tabindex="-1"><a class="header-anchor" href="#光追资源包-纹理包是什么" aria-hidden="true">#</a> 光追资源包 / 纹理包是什么？</h2><p><strong>光追即光线追踪，是 <code>着色器（光影）</code>所使用的技术，与 <code>纹理包</code> 无关。</strong></p><ul><li>现在市面上的所谓 <strong>光追纹理包</strong> 大概率是指 <code>PBR纹理包</code>，其 <strong>包含</strong> 更多 <code>其它纹理包信息</code>；</li><li><strong>传统反射纹理包</strong> 仅有 <code>粗糙度</code> 和 <code>反射率</code>。</li><li>借由 PBR 技术可使物体 <strong>表现出</strong> 该纹理包表面应有的 <code>物理效果</code>（如 <code>金属</code> 和 <code>玻璃</code> 的反射区别，<code>塑料</code> 和 <code>泥土</code> 的反射区别），有效降低了光滑面反射的“油腻感”，使反射更真实（但不属于光追效果）。</li><li>少部分人会将光追纹理包认为是 <code>预烘焙</code> 后保留最终贴图的纹理包。其原因有可能有两点： <ul><li><strong>道听途说的错误说法</strong>；</li><li>其他游戏存在此技术。但 Minecraft 中的方块场景布局随机复杂，这种技术并不理想；</li><li><code>1.17</code> 之后的 <code>纹理包</code> 能够添加 <code>水反</code> 等效果，看起来有所谓光追效果。然而这些反射只是因为 <code>1.17</code> 添加了 <code>纹理包形式的着色器</code> ，没有着色器支持，就不可能添加任何反射。</li></ul></li></ul>',23),a=[r];function l(t,n){return o(),d("div",null,a)}const h=e(i,[["render",l],["__file","texture.html.vue"]]);export{h as default};
